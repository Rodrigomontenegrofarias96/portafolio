# azure-pipelines.yml
# Se activa en:
# - Push / merge a main  -> despliegue a PRODUCCIÓN
# - Pull Request a main  -> solo BUILD (sin deploy a prod)

trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - README.md
      - docs/*

pr:
  branches:
    include:
      - main
  paths:
    exclude:
      - README.md
      - docs/*

pool:
  name: Default

variables:
  # === IMPORTANTE: Variable Group desde Library ===
  - group: variable

  # Variables del sistema
  - name: system.debug
    value: false

  # Variables del proyecto
  - name: deployTag
    value: $(Build.BuildNumber)
  - name: branchName
    value: $(Build.SourceBranchName)
  - name: commitMessage
    value: $(Build.SourceVersionMessage)
  - name: commitAuthor
    value: $(Build.RequestedFor)
  - name: buildReason
    value: $(Build.Reason)

stages:
  - stage: StatusUpdate
    displayName: 'Update Merge/PR Status'
    jobs:
      - job: StatusJob
        displayName: 'Status Tracking'
        steps:
          - bash: |
              set -euo pipefail
              echo "=== PIPELINE DETECTADO ==="
              echo "Branch: $(branchName)"
              echo "Build Reason: $(buildReason)"
              echo "Commit Message: $(commitMessage)"
              echo "Autor: $(commitAuthor)"
              echo "Build Number: $(Build.BuildNumber)"
              echo "Commit ID: $(Build.SourceVersion)"
              echo "Timestamp: $$(date)"
              echo "=========================="

              echo "$$(date): REASON=$(buildReason) - Branch=$(branchName) - Build=$(Build.BuildNumber) - Author=$(commitAuthor) - Commit=$(Build.SourceVersion)" >> merge_status.log
            displayName: 'Log Pipeline Status'

          - task: CopyFiles@2
            inputs:
              Contents: 'merge_status.log'
              TargetFolder: '$(Build.ArtifactStagingDirectory)'
            displayName: 'Stage merge_status.log'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'status'
            displayName: 'Publish status artifact'

  - stage: Build
    displayName: 'Build and Package'
    dependsOn: StatusUpdate
    jobs:
      - job: BuildJob
        displayName: 'Build Job'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '16.x'
            displayName: 'Install Node.js'

          - bash: |
              set -euo pipefail
              npm ci
            displayName: 'Install dependencies'

          - bash: |
              set -euo pipefail
              echo "=== CONFIGURANDO VARIABLES DE ENTORNO ==="

              if [ -z "${REACT_APP_EMAILJS_SERVICE_ID:-}" ]; then
                echo "ERROR: REACT_APP_EMAILJS_SERVICE_ID no está configurada"
                exit 1
              fi

              if [ -z "${REACT_APP_EMAILJS_TEMPLATE_ID:-}" ]; then
                echo "ERROR: REACT_APP_EMAILJS_TEMPLATE_ID no está configurada"
                exit 1
              fi

              if [ -z "${REACT_APP_EMAILJS_PUBLIC_KEY:-}" ]; then
                echo "ERROR: REACT_APP_EMAILJS_PUBLIC_KEY no está configurada"
                exit 1
              fi

              echo "Todas las variables de EmailJS están configuradas ✓"

              echo "Creando archivo .env..."
              printf "REACT_APP_EMAILJS_SERVICE_ID=%s\nREACT_APP_EMAILJS_TEMPLATE_ID=%s\nREACT_APP_EMAILJS_PUBLIC_KEY=%s\n" \
                "$REACT_APP_EMAILJS_SERVICE_ID" \
                "$REACT_APP_EMAILJS_TEMPLATE_ID" \
                "$REACT_APP_EMAILJS_PUBLIC_KEY" > .env

              echo "Variables encontradas en .env:"
              cut -d= -f1 .env
            displayName: 'Configure Environment Variables'
            env:
              REACT_APP_EMAILJS_SERVICE_ID: $(REACT_APP_EMAILJS_SERVICE_ID)
              REACT_APP_EMAILJS_TEMPLATE_ID: $(REACT_APP_EMAILJS_TEMPLATE_ID)
              REACT_APP_EMAILJS_PUBLIC_KEY: $(REACT_APP_EMAILJS_PUBLIC_KEY)

          - bash: |
              set -euo pipefail

              if [ ! -f .env ]; then
                echo "ERROR: Archivo .env no encontrado"
                exit 1
              fi

              echo "Node version: $$(node --version)"
              echo "NPM version: $$(npm --version)"

              npm run build

              if [ ! -d "build" ]; then
                echo "ERROR: Directorio build no fue creado"
                exit 1
              fi

              echo "Build completado exitosamente ✓"
              ls -la build/
            displayName: 'Build React Project'
            env:
              REACT_APP_EMAILJS_SERVICE_ID: $(REACT_APP_EMAILJS_SERVICE_ID)
              REACT_APP_EMAILJS_TEMPLATE_ID: $(REACT_APP_EMAILJS_TEMPLATE_ID)
              REACT_APP_EMAILJS_PUBLIC_KEY: $(REACT_APP_EMAILJS_PUBLIC_KEY)
              CI: true

          - task: ArchiveFiles@2
            inputs:
              rootFolderOrFile: '$(System.DefaultWorkingDirectory)/build'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/build.zip'
              replaceExistingArchive: true
            displayName: 'Archive build files'

          - bash: |
              set -euo pipefail
              printf "build_number=%s\ncommit=%s\nbranch=%s\nreason=%s\n" \
                "$(Build.BuildNumber)" \
                "$(Build.SourceVersion)" \
                "$(Build.SourceBranch)" \
                "$(Build.Reason)" > deploy_meta.txt
              cat deploy_meta.txt
            displayName: 'Create deploy metadata'

          - task: CopyFiles@2
            inputs:
              Contents: |
                build.zip
                deploy_meta.txt
              TargetFolder: '$(Build.ArtifactStagingDirectory)'
            displayName: 'Stage artifacts'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'drop'
            displayName: 'Publish artifacts'

  - stage: Deploy
    displayName: 'Deploy to Production (main only)'
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'), ne(variables['Build.Reason'], 'PullRequest'))
    jobs:
      - job: DeployJob
        displayName: 'Deploy Job'
        steps:
          - task: DownloadBuildArtifacts@0
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'drop'
              downloadPath: '$(System.ArtifactsDirectory)'
            displayName: 'Download build artifacts'

          - bash: |
              set -euo pipefail

              : "${NETLIFY_AUTH_TOKEN:?ERROR: NETLIFY_AUTH_TOKEN no está configurada}"
              : "${NETLIFY_SITE_ID:?ERROR: NETLIFY_SITE_ID no está configurada}"

              ZIP_PATH="$(System.ArtifactsDirectory)/drop/build.zip"
              if [ ! -f "$ZIP_PATH" ]; then
                echo "ERROR: Archivo build.zip no encontrado en $ZIP_PATH"
                ls -la "$(System.ArtifactsDirectory)/drop" || true
                exit 1
              fi

              DEPLOY_TITLE="Production Deploy $(deployTag) - main"
              echo "Iniciando despliegue PROD en Netlify..."
              echo "Site: $NETLIFY_SITE_ID"
              echo "Title: $DEPLOY_TITLE"
              echo "Zip: $ZIP_PATH"

              DEPLOY_RESPONSE="$(curl -sS -X POST \
                -H "Authorization: Bearer $NETLIFY_AUTH_TOKEN" \
                -H "Content-Type: application/zip" \
                --data-binary "@$ZIP_PATH" \
                "https://api.netlify.com/api/v1/sites/$NETLIFY_SITE_ID/deploys")"

              DEPLOY_ID="$(echo "$DEPLOY_RESPONSE" | sed -n 's/.*"id":"\([^"]*\)".*/\1/p' | head -n1)"
              if [ -z "${DEPLOY_ID:-}" ]; then
                echo "ERROR: No se pudo obtener deploy_id"
                echo "Respuesta: $DEPLOY_RESPONSE"
                exit 1
              fi

              echo "Deploy ID: $DEPLOY_ID"

              echo "Esperando que el deploy quede listo..."
              FINAL_STATE=""
              for i in $(seq 1 40); do
                DEPLOY_INFO="$(curl -sS -H "Authorization: Bearer $NETLIFY_AUTH_TOKEN" \
                  "https://api.netlify.com/api/v1/deploys/$DEPLOY_ID")"

                STATE="$(echo "$DEPLOY_INFO" | sed -n 's/.*"state":"\([^"]*\)".*/\1/p' | head -n1)"
                echo "Estado: ${STATE:-unknown} (intento $i)"

                case "$STATE" in
                  ready|current|uploaded)
                    FINAL_STATE="$STATE"
                    break
                    ;;
                  error)
                    echo "ERROR: Deploy en estado error"
                    echo "$DEPLOY_INFO"
                    exit 1
                    ;;
                esac

                sleep 5
              done

              if [ -z "${FINAL_STATE:-}" ]; then
                echo "ERROR: Timeout esperando deploy listo. Revisar dashboard."
                echo "Dashboard: https://app.netlify.com/sites/$NETLIFY_SITE_ID/deploys"
                exit 1
              fi

              printf "deploy_id=%s\nstate=%s\ndashboard=https://app.netlify.com/sites/%s/deploys\n" \
                "$DEPLOY_ID" "$FINAL_STATE" "$NETLIFY_SITE_ID" > netlify_deploy.txt
              cat netlify_deploy.txt

              echo "Deploy PROD OK ✓"
            displayName: 'Deploy Production (stable)'
            env:
              NETLIFY_AUTH_TOKEN: $(NETLIFY_AUTH_TOKEN)
              NETLIFY_SITE_ID: $(NETLIFY_SITE_ID)

          - task: CopyFiles@2
            inputs:
              Contents: 'netlify_deploy.txt'
              TargetFolder: '$(Build.ArtifactStagingDirectory)'
            displayName: 'Stage netlify_deploy.txt'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'deploy-info'
            displayName: 'Publish deploy info'

  - stage: PostDeploy
    displayName: 'Post Status'
    dependsOn: Deploy
    condition: succeededOrFailed()
    jobs:
      - job: FinalStatus
        displayName: 'Final Status Update'
        steps:
          - bash: |
              set -euo pipefail

              echo "=== FINAL STATUS ==="
              echo "Branch: $(branchName)"
              echo "Reason: $(buildReason)"
              echo "Commit: $(Build.SourceVersion)"
              echo "Autor: $(commitAuthor)"
              echo "Build: $(Build.BuildNumber)"
              echo "Timestamp: $$(date)"
              echo "===================="

              echo "$$(date): FINAL - Reason=$(buildReason) - Branch=$(branchName) - Build=$(Build.BuildNumber) - Commit=$(Build.SourceVersion)" >> merge_status.log
            displayName: 'Final Status'
